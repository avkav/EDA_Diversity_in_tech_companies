# -*- coding: utf-8 -*-
"""DiversityInTechCompaniesEDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M42K5gJIP9yfyNUutAoJS3MWzCWXf7OQ

#Diversity in Tech Companies EDA - In progress

By Angela V. Kavrecic

Data Set Font: https://www.kaggle.com/datasets/jainaru/diversity-in-tech-companies

File: https://drive.google.com/file/d/1dP7YZ7rgsWfkgbILzK0minZikFK1tTa7/view?usp=sharing

##Importación y limpieza de datos

###Función para mantener solo enteros:
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


# Cargar datos
df = pd.read_csv('Diversity_in_tech_companies.csv')

# Función para mantener solo enteros y poner 0 en el resto
def only_integers(x):
    return x if isinstance(x, int) else 0

# Identificar el índice de la columna 'Female %'
start_col = df.columns.get_loc('Female %')

# Aplicar la función solo a las columnas desde 'Female %' en adelante
df.iloc[:, start_col:] = df.iloc[:, start_col:].map(only_integers)

# Verificar el resultado
print(df.head())

# Seleccionar las columnas desde 'Female %' en adelante
df_subset = df.iloc[:, start_col:]

# Eliminar duplicados en las columnas seleccionadas
df_subset.drop_duplicates(inplace=True)

# Detección de valores atípicos usando el método IQR
Q1 = df_subset.quantile(0.25)
Q3 = df_subset.quantile(0.75)
IQR = Q3 - Q1
outliers = df_subset[(df_subset < (Q1 - 1.5 * IQR)) | (df_subset > (Q3 + 1.5 * IQR))]

"""##Visualización de datos"""

import matplotlib.pyplot as plt
import seaborn as sns

# Gráfico de dispersión
sns.scatterplot(x='Female %', y='Male %', data=df)

# Histograma
df['Female %'].hist()

# Cargar datos
df = pd.read_csv('Diversity_in_tech_companies.csv')

# Aumentar el tamaño de la figura
plt.figure(figsize=(15, 8))

# Crear el primer diagrama de caja y bigotes para 'Female %'
plt.subplot(2, 1, 1)
sns.boxplot(x='Company', y='Female %', data=df)
plt.xticks(rotation=45, ha='right')
plt.title('Distribución de Female % por Compañía')

# Crear el segundo diagrama de caja y bigotes para 'Male %'
plt.subplot(2, 1, 2)
sns.boxplot(x='Company', y='Male %', data=df)
plt.xticks(rotation=45, ha='right')
plt.title('Distribución de Male % por Compañía')

# Ajustar el diseño para que los subplots no se solapen
plt.tight_layout()

# Mostrar los gráficos
plt.show()

# Gráfico de barras
df['Year'].value_counts().plot(kind='bar')

"""##Análisis estadístico descriptivo"""

# Media
mean = df['Female %'].mean()

# Mediana
median = df['Female %'].median()

# Moda
mode = df['Female %'].mode()

# Varianza
variance = df['Female %'].var()

# Desviación estándar
std_dev = df['Female %'].std()

print("El promedio es:", mean)
print("La mediana es: ", median)
print("La moda es;", mode)
print("La varianza es:",variance)
print("La desviación estandar es: ",std_dev)

"""##Correlación y análisis de variables"""

# Cargar datos
df = pd.read_csv('Diversity_in_tech_companies.csv')

# # Función para mantener solo enteros y poner 0 en el resto
# def only_integers(x):
#     return x if isinstance(x, int) else 0

# # Identificar el índice de la columna 'Female %'
# start_col = df.columns.get_loc('% Latino')

# # Aplicar la función solo a las columnas desde 'Female %' en adelante
# df.iloc[:, start_col:] = df.iloc[:, start_col:].map(only_integers)

# # Verificar el resultado
# print(df.head())

# # Reemplazar caracteres no numéricos con cero en la columna `% Latino`
# df['% Latino'] = df['% Latino'].replace({'-': '0', ',': '.'}, regex=True)

# # Convertir la columna `% Latino` a tipo numérico, forzando los valores no convertibles a cero
# df['% Latino'] = pd.to_numeric(df['% Latino'], errors='coerce').fillna(0)

# Verificar el tipo de datos de la columna `% Latino`
print(df['% Latino'].dtype)

# Verificar los valores únicos en la columna `% Latino`
print(df['% Latino'])

# Verificar el número de filas restantes
print(f'Número de filas restantes: {df.shape[0]}')

# Verificar los valores únicos en las columnas
print(df['% White'].unique())
print(df['% Latino'].unique())

import pandas as pd

# Leer el archivo CSV
df = pd.read_csv('Diversity_in_tech_companies.csv')

# Reemplazar caracteres no numéricos si es necesario (por ejemplo, comas en lugar de puntos)
df['% Latino'] = df['% Latino'].replace({',': '.'}, regex=True)

# Convertir la columna `% Latino` de string a enteros y agregar una nueva columna con estos valores
df['% Latino (int)'] = pd.to_numeric(df['% Latino'], errors='coerce').fillna(0).astype(int)

# Verificar el tipo de datos y valores únicos de la nueva columna
print(df['% Latino (int)'].dtype)
print(df['% Latino (int)'].unique())

# Verificar valores NaN en las columnas de interés
print(df[['% White', '% Latino']].isna().sum())

# Estadísticas descriptivas para las columnas de interés
print(df[['% White','% Latino (int)']].describe())


# Verificar la desviación estándar de las columnas
print(df[['% White', '% Latino (int)']].std())

# Reemplazar '-' con NaN
df.replace('-', np.nan, inplace=True)

# Convertir las columnas específicas a tipo numérico
columns_to_convert = ['% White', '% Asian', '% Latino (int)', '% Black', '% Multi', '% Other', '% Undeclared']
df[columns_to_convert] = df[columns_to_convert].apply(pd.to_numeric, errors='coerce')

# Eliminar filas con valores NaN en las columnas relevantes
df.dropna(subset=columns_to_convert, inplace=True)

# Calcular la correlación de Pearson entre las columnas '% White' y '% Latino'
correlacion_pearson = df['% White'].corr(df['% Latino (int)'])
print(f'Correlación de Pearson: {correlacion_pearson}')

"""##Análisis de distribuciones y normalidad"""

import scipy.stats as stats

# Histograma
df['% Asian'].hist()

# Q-Q plot
stats.probplot(df['% Asian'], dist="norm", plot=plt)

# Prueba de Shapiro-Wilk
shapiro_test = stats.shapiro(df['% Asian'])

"""##Análisis de grupos y segmentación"""

from sklearn.cluster import KMeans
from scipy.cluster.hierarchy import dendrogram, linkage

# K-means clustering
kmeans = KMeans(n_clusters=3)
kmeans.fit(df[['Female %', 'Male %']])

# Análisis jerárquico
linked = linkage(df[['Female %', 'Male %']], 'single')
dendrogram(linked)